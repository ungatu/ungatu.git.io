---
layout: post
title: 'CSAPP第8章笔记'
date: 2021-04-17
author: ungatu
color: rgb(255,210,32)
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: CSAPP 进程 异常信号处理
---


# CSAPP第八章进程

## 8.1
8.1.1
处理器有状态位，在处理指令(一般)时，发生状态位的变化，这就称作事件。
例如，事件与当前指令有关(某条指令试图除以0)为同步，与指令无关(系统定时器产生信号，或者io请求完成)为异步。

有了事件，处理器就会发生指令跳转，
根据异常表，到异常处理程序(操作系统子程序)。
完成处理后，控制有三种可能，返回Icurr,Inext,或者终止被中断的程序

异常就是这种控制流的突变。

跳转到处理程序前，会把返回地址压栈，Icurr,Inext这两种可能发生一种，

处理完成之后，执行“从中断返回”指令，可选的返回不返回
8.1.2
假如异常与指令无关，就是interrupt，

有关，并且是有意的!我用了syscall n指令的结果，就是trap的一类，这是因为想要受控的访问内核服务。可以访问内核栈

错误情况，错误的指令，导致了fault，可以可能被异常处理程序修复，修复就返回Inext，失败就终止，例如缺页异常

终止abort，不可修复，致命错误，从不返回控制给应用程序，而是返回给abort例程，终止那个应用程序。

8.1.3
系统调用，通过一条trap指令提供的
trap，参数是寄存器传递，%rax放第一个参数，然后是那6个，返回的时候%rax有返回值，-4095到-1，对应于负的errno!

### 8.2
进程定义，就是一个执行中程序的实例

逻辑控制流，是个序列，PC值的序列，
物理控制流(处理器)被分成多个逻辑流

并发流，一个逻辑流的在时间上和另一个流出现交叉重叠，成为并发流，轮流执行叫做多任务
多个流，不同的处理器核，叫做并行流，parallel。

用户模式和内核模式，用一个控制寄存器的模式位，描述了进程享有的特权，想要从用户态转变到内核态，唯一办法就是异常处理程序，传递控制。
上下文，内核重启一个被抢占的进程所需的状态，包括寄存器，用户栈，内核栈，
上下文切换，保存当前的，恢复过去的，传递控制
什么时候发生上下文切换呢，在系统调用可能会发生，虽然一般的系统调用不产生新进程，但是系统调用有read，write，wait，sleep，就例如sleep，显式的。还有read，陷阱处理程序请求磁盘，然后切换上下文，等读取完了，磁盘发信号中断
中断的时候也可能引发上下文切换，周期性定时器判断运行时间够长了，就切换
切换是指切换到当前的别的进程!

### 8.3
系统调用遇错，通常返回-1，还设置全局errno，
strerror(errno)可以解析出来字符串，用fprintf输出到stderror(2)
所以记得处理错误，为了不臃肿，用包装函数

### 8.4
getpid，getppid
进程的三状态

运行:在执行它的指令序列，或者等调度过去就执行(挂起，例如waitpid)

停止:被挂起(suspend)且!不在被调度，一般是收到SIGTSTP,SIGSTOP,SIGTTIN,SIGTTOU,
直到收到SIGCONT，信号是种软件中断，也就是说信号不是指令，能带来逻辑流突变

终止:永远的停止，要么收到终止程序的信号，要么从主程序返回，要么调用exit函数

fork产生子进程，虚拟空间相同，但独立(算是副本)，相同的全局变量值!!?

回收子进程，是因为进程保持已终止，回收时，内核将退出状态传递给父进程，然后再抛弃它

waitpid的status得到子进程的退出状态(主程序返回的整数值，或者exit函数以status退出状态)，wait.h的宏里面能解释它

等待集合没有子进程了，就会返回-1，并设置errno为ECHILD,假如被信号中断，那么返回-1，并且设置errno为EINTR。

### 8.5
8.5.5
正确的信号处理，父进程在处理SIGCHLD，又有个子进程结束，抽象级放低，就是(主程序的)pending向量，处理的时候就会把那一位清空，再来个信号，
就是又置为1，但是阻塞了，因为还有没处理完的，暂时不会被接受，这时候再来信号，
!牢记pending向量，
8.5.6

<iframe type="text/html" width="100%" height="385" src="http://www.youtube.com/embed/gfmjMWjn-Xg" frameborder="0"></iframe>
